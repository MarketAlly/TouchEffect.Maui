using System.Windows.Input;
using MarketAlly.TouchEffect.Maui.Enums;
using MarketAlly.TouchEffect.Maui.Extensions;
using MarketAlly.TouchEffect.Maui.Interfaces;

namespace MarketAlly.TouchEffect.Maui;

/// <summary>
/// TouchEffect provides touch and hover visual feedback for any VisualElement.
/// This is the core partial class containing events, instance properties, and logic.
/// </summary>
public partial class TouchEffect : RoutingEffect
{
	#region Visual State Constants

	public const string UnpressedVisualState = TouchEffectConstants.VisualStates.Unpressed;
	public const string PressedVisualState = TouchEffectConstants.VisualStates.Pressed;
	public const string HoveredVisualState = TouchEffectConstants.VisualStates.Hovered;

	#endregion

	#region Static Logger

	private static ITouchEffectLogger _logger = NullTouchEffectLogger.Instance;

	/// <summary>
	/// Sets the logger instance for all TouchEffect operations.
	/// </summary>
	/// <param name="logger">The logger to use. Pass null to disable logging.</param>
	public static void SetLogger(ITouchEffectLogger? logger)
	{
		_logger = logger ?? NullTouchEffectLogger.Instance;
	}

	/// <summary>
	/// Gets the current logger instance.
	/// </summary>
	internal static ITouchEffectLogger Logger => _logger;

	#endregion

	#region Events

	public event EventHandler<TouchStatusChangedEventArgs> StatusChanged
	{
		add => _weakEventManager.AddEventHandler(value);
		remove => _weakEventManager.RemoveEventHandler(value);
	}

	public event EventHandler<TouchStateChangedEventArgs> StateChanged
	{
		add => _weakEventManager.AddEventHandler(value);
		remove => _weakEventManager.RemoveEventHandler(value);
	}

	public event EventHandler<TouchInteractionStatusChangedEventArgs> InteractionStatusChanged
	{
		add => _weakEventManager.AddEventHandler(value);
		remove => _weakEventManager.RemoveEventHandler(value);
	}

	public event EventHandler<HoverStatusChangedEventArgs> HoverStatusChanged
	{
		add => _weakEventManager.AddEventHandler(value);
		remove => _weakEventManager.RemoveEventHandler(value);
	}

	public event EventHandler<HoverStateChangedEventArgs> HoverStateChanged
	{
		add => _weakEventManager.AddEventHandler(value);
		remove => _weakEventManager.RemoveEventHandler(value);
	}

	public event EventHandler<TouchCompletedEventArgs> Completed
	{
		add => _weakEventManager.AddEventHandler(value);
		remove => _weakEventManager.RemoveEventHandler(value);
	}

	public event EventHandler<LongPressCompletedEventArgs> LongPressCompleted
	{
		add => _weakEventManager.AddEventHandler(value);
		remove => _weakEventManager.RemoveEventHandler(value);
	}

	#endregion

	#region Fields

	private readonly GestureManager _gestureManager;
	private readonly WeakEventManager _weakEventManager;
	private VisualElement? _element;

	#endregion

	#region Constructor

	public TouchEffect()
	{
		_gestureManager = new GestureManager();
		_weakEventManager = new WeakEventManager();
	}

	#endregion

	#region Property Changed Handlers

	private static void TryGenerateEffect(BindableObject? bindable, object oldValue, object newValue)
	{
		if (bindable is not VisualElement view)
			return;

		// Optimize: Use cached check instead of LINQ
		if (HasTouchEffect(view))
			return;

		view.Effects.Add(new TouchEffect { IsAutoGenerated = true });
	}

	private static void ForceUpdateStateAndTryGenerateEffect(BindableObject bindable, object oldValue, object newValue)
	{
		GetFrom(bindable)?.ForceUpdateState(animated: true);
		TryGenerateEffect(bindable, oldValue, newValue);
	}

	private static void ForceUpdateStateWithoutAnimationAndTryGenerateEffect(BindableObject bindable, object oldValue, object newValue)
	{
		// FIX: Pass animated: false to actually disable animation
		GetFrom(bindable)?.ForceUpdateState(animated: false);
		TryGenerateEffect(bindable, oldValue, newValue);
	}

	private static void SetChildrenInputTransparentAndTryGenerateEffect(BindableObject bindable, object oldValue, object newValue)
	{
		GetFrom(bindable)?.SetChildrenInputTransparent((bool)newValue);
		TryGenerateEffect(bindable, oldValue, newValue);
	}

	#endregion

	#region Internal Properties

	internal bool IsDisabled { get; set; }
	internal bool IsUsed { get; set; }
	internal bool IsAutoGenerated { get; set; }

	internal new VisualElement? Element
	{
		get => _element;
		set
		{
			if (_element != null)
			{
				IsUsed = false;
				_gestureManager.Reset();
				SetChildrenInputTransparent(false);
			}

			_gestureManager.AbortAnimations(this);
			_element = value;

			if (value != null)
			{
				SetChildrenInputTransparent(ShouldMakeChildrenInputTransparent);
				if (!IsAutoGenerated)
				{
					IsUsed = true;
					DisableOtherTouchEffects(value);
				}

				ForceUpdateState();
			}
		}
	}

	internal bool CanExecute => IsAvailable
								&& (Element?.IsEnabled ?? false)
								&& (Command?.CanExecute(CommandParameter) ?? true);

	#endregion

	#region Instance Property Accessors

	public bool IsAvailable => GetIsAvailable(Element);
	public bool ShouldMakeChildrenInputTransparent => GetShouldMakeChildrenInputTransparent(Element);
	public ICommand? Command => GetCommand(Element);
	public ICommand? LongPressCommand => GetLongPressCommand(Element);
	public object? CommandParameter => GetCommandParameter(Element);
	public object? LongPressCommandParameter => GetLongPressCommandParameter(Element);
	public int LongPressDuration => GetLongPressDuration(Element);

	public TouchStatus Status
	{
		get => GetStatus(Element);
		internal set => SetStatus(Element, value);
	}

	public TouchState State
	{
		get => GetState(Element);
		internal set => SetState(Element, value);
	}

	public TouchInteractionStatus InteractionStatus
	{
		get => GetInteractionStatus(Element);
		internal set => SetInteractionStatus(Element, value);
	}

	public HoverStatus HoverStatus
	{
		get => GetHoverStatus(Element);
		internal set => SetHoverStatus(Element, value);
	}

	public HoverState HoverState
	{
		get => GetHoverState(Element);
		internal set => SetHoverState(Element, value);
	}

	public int DisallowTouchThreshold => GetDisallowTouchThreshold(Element);
	public bool NativeAnimation => GetNativeAnimation(Element);
	public Color? NativeAnimationColor => GetNativeAnimationColor(Element);
	public int NativeAnimationRadius => GetNativeAnimationRadius(Element);
	public int NativeAnimationShadowRadius => GetNativeAnimationShadowRadius(Element);
	public bool NativeAnimationBorderless => GetNativeAnimationBorderless(Element);
	public Color? NormalBackgroundColor => GetNormalBackgroundColor(Element);
	public Color? HoveredBackgroundColor => GetHoveredBackgroundColor(Element);
	public Color? PressedBackgroundColor => GetPressedBackgroundColor(Element);
	public double NormalOpacity => GetNormalOpacity(Element);
	public double HoveredOpacity => GetHoveredOpacity(Element);
	public double PressedOpacity => GetPressedOpacity(Element);
	public double NormalScale => GetNormalScale(Element);
	public double HoveredScale => GetHoveredScale(Element);
	public double PressedScale => GetPressedScale(Element);
	public double NormalTranslationX => GetNormalTranslationX(Element);
	public double HoveredTranslationX => GetHoveredTranslationX(Element);
	public double PressedTranslationX => GetPressedTranslationX(Element);
	public double NormalTranslationY => GetNormalTranslationY(Element);
	public double HoveredTranslationY => GetHoveredTranslationY(Element);
	public double PressedTranslationY => GetPressedTranslationY(Element);
	public double NormalRotation => GetNormalRotation(Element);
	public double HoveredRotation => GetHoveredRotation(Element);
	public double PressedRotation => GetPressedRotation(Element);
	public double NormalRotationX => GetNormalRotationX(Element);
	public double HoveredRotationX => GetHoveredRotationX(Element);
	public double PressedRotationX => GetPressedRotationX(Element);
	public double NormalRotationY => GetNormalRotationY(Element);
	public double HoveredRotationY => GetHoveredRotationY(Element);
	public double PressedRotationY => GetPressedRotationY(Element);
	public int AnimationDuration => GetAnimationDuration(Element);
	public Easing? AnimationEasing => GetAnimationEasing(Element);
	public int PressedAnimationDuration => GetPressedAnimationDuration(Element);
	public Easing? PressedAnimationEasing => GetPressedAnimationEasing(Element);
	public int NormalAnimationDuration => GetNormalAnimationDuration(Element);
	public Easing? NormalAnimationEasing => GetNormalAnimationEasing(Element);
	public int HoveredAnimationDuration => GetHoveredAnimationDuration(Element);
	public Easing? HoveredAnimationEasing => GetHoveredAnimationEasing(Element);
	public int PulseCount => GetPulseCount(Element);

	public bool? IsToggled
	{
		get => GetIsToggled(Element);
		internal set => SetIsToggled(Element, value);
	}

	public ImageSource? NormalBackgroundImageSource => GetNormalBackgroundImageSource(Element);
	public ImageSource? HoveredBackgroundImageSource => GetHoveredBackgroundImageSource(Element);
	public ImageSource? PressedBackgroundImageSource => GetPressedBackgroundImageSource(Element);
	public Aspect BackgroundImageAspect => GetBackgroundImageAspect(Element);
	public Aspect NormalBackgroundImageAspect => GetNormalBackgroundImageAspect(Element);
	public Aspect HoveredBackgroundImageAspect => GetHoveredBackgroundImageAspect(Element);
	public Aspect PressedBackgroundImageAspect => GetPressedBackgroundImageAspect(Element);
	public bool ShouldSetImageOnAnimationEnd => GetShouldSetImageOnAnimationEnd(Element);

	#endregion

	#region Static Helpers

	/// <summary>
	/// Optimized check for TouchEffect presence without LINQ allocation.
	/// </summary>
	private static bool HasTouchEffect(VisualElement view)
	{
		var effects = view.Effects;
		for (int i = 0; i < effects.Count; i++)
		{
			if (effects[i] is TouchEffect)
				return true;
		}
		return false;
	}

	/// <summary>
	/// Gets the TouchEffect from a bindable object, preferring non-auto-generated effects.
	/// Optimized to avoid LINQ allocations.
	/// </summary>
	internal static TouchEffect? GetFrom(BindableObject? bindable)
	{
		if (bindable is not VisualElement view)
			return null;

		var effects = view.Effects;
		TouchEffect? autoGenerated = null;

		for (int i = 0; i < effects.Count; i++)
		{
			if (effects[i] is TouchEffect te)
			{
				if (!te.IsAutoGenerated)
					return te;
				autoGenerated ??= te;
			}
		}

		return autoGenerated;
	}

	/// <summary>
	/// Picks an available TouchEffect for use, preferring unused non-auto-generated effects.
	/// Optimized to avoid LINQ allocations.
	/// </summary>
	internal static TouchEffect? PickFrom(BindableObject? bindable)
	{
		if (bindable is not VisualElement view)
			return null;

		var effects = view.Effects;
		TouchEffect? autoGenerated = null;
		TouchEffect? anyEffect = null;

		for (int i = 0; i < effects.Count; i++)
		{
			if (effects[i] is TouchEffect te)
			{
				anyEffect ??= te;

				if (!te.IsAutoGenerated && !te.IsUsed)
					return te;

				if (te.IsAutoGenerated)
					autoGenerated ??= te;
			}
		}

		return autoGenerated ?? anyEffect;
	}

	/// <summary>
	/// Disables other TouchEffect instances on the same element.
	/// </summary>
	private void DisableOtherTouchEffects(VisualElement view)
	{
		var effects = view.Effects;
		for (int i = 0; i < effects.Count; i++)
		{
			if (effects[i] is TouchEffect te && te != this)
			{
				te.IsDisabled = true;
			}
		}
	}

	#endregion

	#region Touch Handling

	internal void HandleTouch(TouchStatus status)
	{
		_gestureManager.HandleTouch(this, status);
	}

	internal void HandleUserInteraction(TouchInteractionStatus interactionStatus)
	{
		GestureManager.HandleUserInteraction(this, interactionStatus);
	}

	internal void HandleHover(HoverStatus status)
	{
		GestureManager.HandleHover(this, status);
	}

	#endregion

	#region Event Raising

	internal void RaiseStateChanged()
	{
		ForceUpdateState();
		HandleLongPress();

		if (Element is null)
			return;

		_weakEventManager.HandleEvent(Element, new TouchStateChangedEventArgs(State), nameof(StateChanged));
	}

	internal void RaiseInteractionStatusChanged()
	{
		if (Element is null)
			return;

		_weakEventManager.HandleEvent(Element, new TouchInteractionStatusChangedEventArgs(InteractionStatus), nameof(InteractionStatusChanged));
	}

	internal void RaiseStatusChanged()
	{
		if (Element is null)
			return;

		_weakEventManager.HandleEvent(Element, new TouchStatusChangedEventArgs(Status), nameof(StatusChanged));
	}

	internal void RaiseHoverStateChanged()
	{
		ForceUpdateState();

		if (Element is null)
			return;

		_weakEventManager.HandleEvent(Element, new HoverStateChangedEventArgs(HoverState), nameof(HoverStateChanged));
	}

	internal void RaiseHoverStatusChanged()
	{
		if (Element is null)
			return;

		_weakEventManager.HandleEvent(Element, new HoverStatusChangedEventArgs(HoverStatus), nameof(HoverStatusChanged));
	}

	internal void RaiseCompleted()
	{
		var cElement = Element;
		if (cElement == null)
			return;

		var parameter = CommandParameter;

		try
		{
			Command?.Execute(parameter);
		}
		catch (Exception ex)
		{
			_logger.LogError(ex, "RaiseCompleted", "Error executing Command");
		}

		_weakEventManager.HandleEvent(cElement, new TouchCompletedEventArgs(parameter), nameof(Completed));
	}

	internal void RaiseLongPressCompleted()
	{
		var cElement = Element;
		if (cElement == null)
			return;

		var parameter = LongPressCommandParameter ?? CommandParameter;

		try
		{
			LongPressCommand?.Execute(parameter);
		}
		catch (Exception ex)
		{
			_logger.LogError(ex, "RaiseLongPressCompleted", "Error executing LongPressCommand");
		}

		_weakEventManager.HandleEvent(cElement, new LongPressCompletedEventArgs(parameter), nameof(LongPressCompleted));
	}

	#endregion

	#region State Management

	internal void ForceUpdateState(bool animated = true)
	{
		if (Element == null)
			return;

		_gestureManager.ChangeStateAsync(this, animated).SafeFireAndForget(ex =>
			_logger.LogError(ex, "ForceUpdateState", "Error during state change animation"));
	}

	internal void HandleLongPress()
	{
		if (Element == null)
			return;

		_gestureManager.HandleLongPress(this);
	}

	#endregion

	#region Children Input Transparency

	private void SetChildrenInputTransparent(bool value)
	{
		if (Element is not Layout layout)
			return;

		layout.ChildAdded -= OnLayoutChildAdded;

		if (!value)
			return;

		layout.InputTransparent = false;
		foreach (var child in layout.Children)
		{
			if (child is Element element)
			{
				OnLayoutChildAdded(layout, new ElementEventArgs(element));
			}
		}

		layout.ChildAdded += OnLayoutChildAdded;
	}

	private void OnLayoutChildAdded(object? sender, ElementEventArgs e)
	{
		if (e.Element is not View view)
			return;

		if (!ShouldMakeChildrenInputTransparent)
		{
			view.InputTransparent = false;
			return;
		}

		var effect = GetFrom(view);
		view.InputTransparent = effect?.Element == null || !effect.IsAvailable;
	}

	#endregion
}
